<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>写真加工アプリ</title>
<style>
  :root{
    --bg:#0f1720;
    --card:#ffffff;
    --muted:#6b7280;
    --accent:#1565d8;
    --safe-pad:16px;
  }
  html,body{height:100%;margin:0;}
  body{
    font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
    background: linear-gradient(180deg,#0f1720 0%, #071029 100%);
    color:#0b1220;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    padding:calc(var(--safe-pad) + 8px);
    box-sizing:border-box;
  }

  .app {
    width:100%;
    max-width:920px;
    background: #fff;
    border-radius:14px;
    box-shadow: 0 8px 30px rgba(2,6,23,0.45);
    padding:18px;
    box-sizing:border-box;
    position: relative;
  }

  /* Loading Overlay */
  #loadingOverlay {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(255,255,255,0.85);
    z-index: 100;
    border-radius: 14px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    color: var(--accent);
    display: none; /* hidden by default */
  }
  .spinner {
    width: 40px; height: 40px;
    border: 4px solid #ddd;
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-bottom: 10px;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  h1{font-size:18px;margin:0;}
  .controls-top{
    display:flex;
    gap:10px;
    align-items:center;
  }
  /* 重要: acceptを具体的に指定することでiOSに変換を強制させる */
  #fileInput{
    appearance:none;
  }

  .main {
    margin-top:14px;
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:center;
  }

  .canvas-wrap{
    width:100%;
    background:#111;
    border-radius:10px;
    padding:8px;
    display:flex;
    align-items:center;
    justify-content:center;
    min-height: 200px;
  }

  canvas{
    max-width:100%;
    width:100%;
    height:auto;
    border-radius:8px;
    background:#ddd;
    touch-action: manipulation;
  }

  .slider-row{
    width:100%;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
  }

  .slider-row label{
    font-size:14px;color:var(--muted);
    display:flex;
    align-items:center;
    gap:8px;
  }

  .range{
    width:90%;
    max-width:540px;
  }

  .btn-row{
    width:100%;
    margin-top:6px;
    display:flex;
    gap:10px;
    justify-content:center;
  }

  button, .file-btn{
    background:var(--accent);
    color:white;
    border:none;
    padding:10px 14px;
    border-radius:10px;
    font-size:15px;
    cursor:pointer;
    box-shadow:0 4px 10px rgba(21,101,216,0.18);
    text-align: center;
  }
  button.secondary{
    background:#e6e6e6;
    color:#0b1220;
    box-shadow:none;
  }

  #filterBar{
    margin-top:12px;
    display:flex;
    gap:10px;
    overflow-x:auto;
    padding:10px;
    background:linear-gradient(180deg, rgba(0,0,0,0.03), rgba(0,0,0,0.01));
    border-radius:10px;
    width: 100%;
    box-sizing: border-box;
  }
  .filterItem{
    min-width:82px;
    flex:0 0 auto;
    background:#fff;
    border-radius:10px;
    border:1px solid #eee;
    padding:8px;
    box-sizing:border-box;
    text-align:center;
    font-size:13px;
    color:#222;
    cursor:pointer;
    user-select:none;
  }
  .filterItem.active{
    border-color:var(--accent);
    box-shadow:0 6px 18px rgba(21,101,216,0.12);
  }
  .thumb{
    width:64px;height:48px;border-radius:6px;background:#ddd;margin:0 auto 6px auto; display:block;
    object-fit:cover;
  }

/* --- スクロールバーのカスタマイズをここから挿入 --- */

  /* 1. スクロールバー全体のサイズを定義 */
  #filterBar::-webkit-scrollbar {
    width: 8px; /* 縦スクロールの場合の幅 */
    height: 12px; /* 横スクロールの場合の高さ (つまみを太くする値) */
  }

  /* 2. トラック（溝）のスタイルを定義 */
  #filterBar::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.1); /* 薄い背景色 */
    border-radius: 10px;
  }

  /* 3. つまみ（サム）のスタイルを定義 */
  #filterBar::-webkit-scrollbar-thumb {
    background: var(--accent); /* テーマカラー (青) を適用 */
    border-radius: 30px; 
  }

  /* 4. ホバー時のつまみの色 */
  #filterBar::-webkit-scrollbar-thumb:hover {
    background: #0f4392; /* 少し濃い色 */
  }

/* --- スクロールバーのカスタマイズの挿入はここまで --- */
  
  @media (max-width:520px){
    .btn-row{flex-direction:column;}
    .filterItem{min-width:72px;padding:6px;font-size:12px;}
    .thumb{width:56px;height:40px;}
  }

  footer{margin-top:12px;font-size:12px;color:var(--muted);text-align:center}
</style>
</head>
<body>
  <div class="app" role="application" aria-label="写真フィルタアプリ">
    <div id="loadingOverlay">
      <div class="spinner"></div>
      <div id="loadingText">画像を処理中...</div>
    </div>

    <header>
      <h1>写真加工アプリ</h1>
      <div class="controls-top">
        <label class="file-btn" for="fileInput" title="写真を選択">写真を選ぶ</label>
        <input id="fileInput" type="file" accept="image/jpeg, image/png" style="display:none">
      </div>
    </header>

    <div class="main">
      <div class="canvas-wrap" aria-live="polite">
        <canvas id="canvas" width="800" height="500"></canvas>
      </div>

      <div class="slider-row" id="sliderRow" style="display:none">
        <label id="sliderLabel">強度：<strong id="sliderValue">1.00</strong></label>
        <input id="strengthSlider" class="range" type="range" min="0" max="1" step="0.01" value="1">
      </div>

      <div class="btn-row">
        <button id="downloadBtn" class="secondary">画像を保存</button>
        <button id="resetBtn">リセット</button>
      </div>

      <div id="filterBar" aria-hidden="false"></div>
    </div>

    <footer>※ 画像は端末内で処理され、外部へ送信されません。</footer>
  </div>

<script>
/* --------- Globals & DOM ---------- */
const fileInput = document.getElementById('fileInput');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const filterBar = document.getElementById('filterBar');
const sliderRow = document.getElementById('sliderRow');
const strengthSlider = document.getElementById('strengthSlider');
const sliderLabel = document.getElementById('sliderLabel');
const sliderValue = document.getElementById('sliderValue');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');
const loadingOverlay = document.getElementById('loadingOverlay');

let originalImageData = null;
let originalImg = null;
let currentFilter = 'original';
let thumbWidth = 128, thumbHeight = 80;

/* --------- UI Helpers ---------- */
function showLoading(show){
  loadingOverlay.style.display = show ? 'flex' : 'none';
}

/* --------- Filters definition --------- */
const filters = [
  { id:'original', name:'Original' },
  { id:'sepia', name:'セピア' },
  { id:'retro', name:'レトロ風' },
  { id:'mini', name:'ミニチュア' }
];

function createFilterBar(){
  filterBar.innerHTML = '';
  filters.forEach(f=>{
    const item = document.createElement('div');
    item.className = 'filterItem';
    item.dataset.filter = f.id;

    const img = document.createElement('canvas');
    img.className = 'thumb';
    img.width = thumbWidth;
    img.height = thumbHeight;
    img.style.display = 'block';

    const label = document.createElement('div');
    label.textContent = f.name;

    item.appendChild(img);
    item.appendChild(label);
    filterBar.appendChild(item);

    item.addEventListener('click', ()=> {
      if(!originalImageData) return;
      setActiveFilter(f.id);
      // use setTimeout to allow UI to update active class before heavy render
      setTimeout(()=>{
        showLoading(true);
        // tiny delay to render loader
        requestAnimationFrame(async ()=>{
            await renderCurrent();
            showLoading(false);
        });
      }, 10);
    });
  });
}

function setActiveFilter(id){
  currentFilter = id;
  document.querySelectorAll('.filterItem').forEach(el=>{
    el.classList.toggle('active', el.dataset.filter === id);
  });

  if(id === 'original'){
    sliderRow.style.display = 'none';
  } else {
    sliderRow.style.display = 'flex';
    if(id === 'sepia') sliderLabel.innerHTML = 'セピア強度：<strong id="sliderValue">'+Number(strengthSlider.value).toFixed(2)+'</strong>';
    else if(id === 'retro') sliderLabel.innerHTML = 'レトロ度：<strong id="sliderValue">'+Number(strengthSlider.value).toFixed(2)+'</strong>';
    else if(id === 'mini') sliderLabel.innerHTML = 'ミニチュア度：<strong id="sliderValue">'+Number(strengthSlider.value).toFixed(2)+'</strong>';
    
    // rebind ref
    sliderValueRef = document.getElementById('sliderValue');
    sliderValueRef.textContent = Number(strengthSlider.value).toFixed(2);
  }
}

/* --------- Image Load Logic ---------- */
fileInput.addEventListener('change', async (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;

  showLoading(true);
  
  // Create object URL
  const url = URL.createObjectURL(file);
  
  try {
    await loadImage(url);
    // iOS sometimes retains file input value, clear it to allow re-selection of same file
    fileInput.value = ''; 
  } catch(err) {
    alert('画像の読み込みに失敗しました。別の画像をお試しください。');
    console.error(err);
  } finally {
    URL.revokeObjectURL(url);
    showLoading(false);
  }
});

function loadImage(src){
  return new Promise((res,rej)=>{
    const img = new Image();
    img.onload = ()=>{
      originalImg = img;
      // limit size to 1200px (Performance on iOS)
      const maxW = 1200;
      let w = img.naturalWidth, h = img.naturalHeight;
      if(w > maxW){
        const ratio = maxW / w;
        w = maxW; h = Math.round(h * ratio);
      }
      canvas.width = w;
      canvas.height = h;
      ctx.drawImage(img, 0, 0, w, h);
      originalImageData = ctx.getImageData(0,0,canvas.width, canvas.height);
      
      updateAllThumbnails();
      setActiveFilter('sepia'); 
      renderCurrent();
      res();
    };
    img.onerror = (e) => rej(e);
    img.src = src;
  });
}

/* --------- Utility functions ---------- */
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

function copyImageData(src){
  return new ImageData(new Uint8ClampedArray(src.data), src.width, src.height);
}

/* --------- Manual Blur Implementation for iOS Support ---------- */
/* ブラウザの filter = 'blur()' はiOS Safariでバグが多いため、
   JavaScriptによる手動Box Blur(近似ガウス)を実装します。
   3回通すことでガウスぼかしに近づけます。
*/
function boxBlurH(scl, tcl, w, h, r) {
    var iarr = 1 / (r+r+1);
    for(var i=0; i<h; i++) {
        var ti = i*w, li = ti, ri = ti+r;
        var fv = scl[ti], lv = scl[ti+w-1], val = (r+1)*fv;
        for(var j=0; j<r; j++) val += scl[ti+j];
        for(var j=0  ; j<=r ; j++) { val += scl[ri++] - fv       ; tcl[ti++] = Math.round(val*iarr); }
        for(var j=r+1; j<w-r; j++) { val += scl[ri++] - scl[li++]; tcl[ti++] = Math.round(val*iarr); }
        for(var j=w-r; j<w  ; j++) { val += lv        - scl[li++]; tcl[ti++] = Math.round(val*iarr); }
    }
}
function boxBlurT(scl, tcl, w, h, r) {
    var iarr = 1 / (r+r+1);
    for(var i=0; i<w; i++) {
        var ti = i, li = ti, ri = ti+r*w;
        var fv = scl[ti], lv = scl[ti+w*(h-1)], val = (r+1)*fv;
        for(var j=0; j<r; j++) val += scl[ti+j*w];
        for(var j=0  ; j<=r ; j++) { val += scl[ri] - fv     ; tcl[ti] = Math.round(val*iarr); ri+=w; ti+=w; }
        for(var j=r+1; j<h-r; j++) { val += scl[ri] - scl[li]; tcl[ti] = Math.round(val*iarr); li+=w; ri+=w; ti+=w; }
        for(var j=h-r; j<h  ; j++) { val += lv      - scl[li]; tcl[ti] = Math.round(val*iarr); li+=w; ti+=w; }
    }
}
function boxBlur(scl, tcl, w, h, r) {
    for(var i=0; i<scl.length; i++) tcl[i] = scl[i];
    boxBlurH(tcl, scl, w, h, r);
    boxBlurT(scl, tcl, w, h, r);
}
// Apply Box Blur to ImageData (only RGB, ignores Alpha for simplicity or copies it)
function applyManualBlur(imageData, radius) {
    // 整数半径
    var r = Math.round(radius);
    if(r < 1) return copyImageData(imageData);

    var w = imageData.width;
    var h = imageData.height;
    var data = new Uint8ClampedArray(imageData.data); // Copy
    
    // Separate channels for processing
    var rCh = new Uint8Array(w*h);
    var gCh = new Uint8Array(w*h);
    var bCh = new Uint8Array(w*h);
    
    for(var i=0; i<w*h; i++) {
        rCh[i] = data[i*4];
        gCh[i] = data[i*4+1];
        bCh[i] = data[i*4+2];
    }
    
    // Temp buffers
    var rT = new Uint8Array(w*h);
    var gT = new Uint8Array(w*h);
    var bT = new Uint8Array(w*h);

    // 2 passes for smoother look
    boxBlur(rCh, rT, w, h, r);
    boxBlur(gCh, gT, w, h, r);
    boxBlur(bCh, bT, w, h, r);
    
    boxBlur(rCh, rT, w, h, r);
    boxBlur(gCh, gT, w, h, r);
    boxBlur(bCh, bT, w, h, r);

    // Write back
    var out = new ImageData(w, h);
    var od = out.data;
    for(var i=0; i<w*h; i++) {
        od[i*4]   = rCh[i];
        od[i*4+1] = gCh[i];
        od[i*4+2] = bCh[i];
        od[i*4+3] = data[i*4+3]; // preserve alpha
    }
    return out;
}


/* --------- Core Filter Logic ---------- */

/* Sepia */
function applySepiaToImageData(srcImageData, strength){
  const img = copyImageData(srcImageData);
  const d = img.data;
  for(let i=0;i<d.length;i+=4){
    const r = d[i], g = d[i+1], b = d[i+2];
    const sr = (r * .393) + (g * .769) + (b * .189);
    const sg = (r * .349) + (g * .686) + (b * .168);
    const sb = (r * .272) + (g * .534) + (b * .131);
    d[i]   = r * (1-strength) + sr * strength;
    d[i+1] = g * (1-strength) + sg * strength;
    d[i+2] = b * (1-strength) + sb * strength;
  }
  return img;
}

/* Retro */
function applyRetroToImageData(srcImageData, strength){
  const width = srcImageData.width, height = srcImageData.height;
  const img = copyImageData(srcImageData);
  const d = img.data;
  const cx = width/2, cy = height/2;
  const maxDist = Math.sqrt(cx*cx + cy*cy);
  const desatAmount = 0.5 * strength;
  const grainAmount = 20 * strength;
  const vignettePower = 0.9 * strength;
  
  for(let y=0;y<height;y++){
    for(let x=0;x<width;x++){
      const i = (y*width + x)*4;
      let r = d[i], g = d[i+1], b = d[i+2];
      const lum = 0.299*r + 0.587*g + 0.114*b;
      r = r*(1-desatAmount) + lum*desatAmount;
      g = g*(1-desatAmount) + lum*desatAmount;
      b = b*(1-desatAmount) + lum*desatAmount;
      
      const sr = (r * 0.35) + (g * 0.65) + (b * 0.12);
      const sg = (r * 0.25) + (g * 0.6)  + (b * 0.08);
      const sb = (r * 0.12) + (g * 0.35) + (b * 0.05);
      
      r = r*(0.6) + sr*0.4;
      g = g*(0.6) + sg*0.4;
      b = b*(0.6) + sb*0.4;
      
      const gRand = (Math.random()-0.5) * grainAmount;
      r += gRand; g += gRand; b += gRand;
      
      const dx = x-cx, dy = y-cy;
      const dnorm = Math.sqrt(dx*dx + dy*dy) / maxDist;
      const v = 1 - Math.pow(Math.min(1, dnorm), 2.0 * (1 + vignettePower));
      r *= v; g *= v; b *= v;
      
      d[i] = clamp(Math.round(r), 0, 255);
      d[i+1] = clamp(Math.round(g), 0, 255);
      d[i+2] = clamp(Math.round(b), 0, 255);
    }
  }
  // blend original
  const out = copyImageData(srcImageData);
  const od = out.data;
  for(let i=0;i<od.length;i+=4){
    od[i]   = od[i]   * (1 - strength) + d[i]   * strength;
    od[i+1] = od[i+1] * (1 - strength) + d[i+1] * strength;
    od[i+2] = od[i+2] * (1 - strength) + d[i+2] * strength;
    od[i+3] = d[i+3];
  }
  return out;
}

/* Miniature - Vividness + Manual Blur */
function applyVividness(srcImageData) {
  const w = srcImageData.width, h = srcImageData.height;
  const out = copyImageData(srcImageData);
  const d = out.data;
  
  // Contrast & Saturation constants
  const contrast = 1.2; 
  const saturation = 1.4; 

  for(let i=0; i<d.length; i+=4) {
    let r = d[i], g = d[i+1], b = d[i+2];

    // 1. Contrast
    r = (r - 128) * contrast + 128;
    g = (g - 128) * contrast + 128;
    b = (b - 128) * contrast + 128;
    
    r = clamp(r, 0, 255); g = clamp(g, 0, 255); b = clamp(b, 0, 255);

    // 2. Saturation
    const gray = 0.2126*r + 0.7152*g + 0.0722*b;
    r = gray + (r - gray) * saturation;
    g = gray + (g - gray) * saturation;
    b = gray + (b - gray) * saturation;

    d[i] = clamp(r, 0, 255); d[i+1] = clamp(g, 0, 255); d[i+2] = clamp(b, 0, 255);
  }
  return out;
}

/* Main Miniature Function */
async function applyMiniature(srcImageData, strength) {
  // 1. Vivid
  const vividData = applyVividness(srcImageData);
  const w = vividData.width, h = vividData.height;

  // 2. Manual Blur (Replacing ctx.filter)
  const maxBlur = 6.0; 
  const blurRadius = Math.max(1, maxBlur * strength); 
  
  // ブラウザAPIを使わずJSで計算（iOS対応）
  const blurredData = applyManualBlur(vividData, blurRadius);
  
  // 3. Alpha Blend
  const out = copyImageData(vividData);
  const od = out.data;
  const sd = vividData.data; 
  const bd = blurredData.data; 
  
  const centerY = h / 2;
  const sharpBandWidth = h * (0.35 - 0.15 * strength); 
  const transitionWidth = h * 0.15; 
  
  for(let y=0; y<h; y++){
    const dist = Math.abs(y - centerY);
    let alpha = 0;
    
    if(dist < sharpBandWidth / 2) {
      alpha = 1;
    } else {
      const distBeyond = dist - (sharpBandWidth / 2);
      const t = 1 - (distBeyond / transitionWidth);
      alpha = clamp(t, 0, 1);
      alpha = alpha * alpha * (3 - 2 * alpha);
    }
    
    for(let x=0; x<w; x++){
      const i = (y*w + x)*4;
      if(alpha >= 0.99) {
        od[i] = sd[i]; od[i+1] = sd[i+1]; od[i+2] = sd[i+2];
      } else if(alpha <= 0.01) {
        od[i] = bd[i]; od[i+1] = bd[i+1]; od[i+2] = bd[i+2];
      } else {
        od[i]   = sd[i]*alpha + bd[i]*(1-alpha);
        od[i+1] = sd[i+1]*alpha + bd[i+1]*(1-alpha);
        od[i+2] = sd[i+2]*alpha + bd[i+2]*(1-alpha);
      }
      od[i+3] = 255;
    }
  }
  return out;
}

/* --------- Render logic ---------- */
let sliderValueRef = sliderValue;

async function renderCurrent(){
  if(!originalImageData) return;
  const strength = parseFloat(strengthSlider.value);
  andShowSliderVal(strength);
  
  // Use setTimeout to ensure UI remains responsive during heavy calc
  return new Promise(resolve => {
    setTimeout(async () => {
        if(currentFilter === 'original'){
            ctx.putImageData(originalImageData, 0, 0);
        } else if(currentFilter === 'sepia'){
            const out = applySepiaToImageData(originalImageData, strength);
            ctx.putImageData(out, 0, 0);
        } else if(currentFilter === 'retro'){
            const out = applyRetroToImageData(originalImageData, strength);
            ctx.putImageData(out, 0, 0);
        } else if(currentFilter === 'mini'){
            const out = await applyMiniature(originalImageData, strength);
            ctx.putImageData(out, 0, 0);
        }
        resolve();
    }, 0);
  });
}

function andShowSliderVal(v){
  if(!sliderValueRef){
    sliderValueRef = document.getElementById('sliderValue');
  }
  sliderValueRef.textContent = Number(v).toFixed(2);
}

/* Debounce for slider to prevent freezing while dragging */
let renderTimeout;
strengthSlider.addEventListener('input', ()=>{
  andShowSliderVal(strengthSlider.value);
  clearTimeout(renderTimeout);
  renderTimeout = setTimeout(()=>{
      showLoading(true);
      requestAnimationFrame(async ()=>{
          await renderCurrent();
          showLoading(false);
      });
  }, 100);
});

downloadBtn.addEventListener('click', ()=>{
  if(!originalImageData) return alert('まずは画像を選択してください');
  const url = canvas.toDataURL('image/jpeg', 0.85);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${currentFilter || 'image'}_edited.jpg`;
  a.click();
});

resetBtn.addEventListener('click', ()=>{
  if(!originalImageData) return;
  strengthSlider.value = 1;
  setActiveFilter('original');
  renderCurrent();
});

function updateAllThumbnails(){
  // Create scaled down temp image
  const iw = originalImageData.width, ih = originalImageData.height;
  const tmp = document.createElement('canvas');
  tmp.width = iw; tmp.height = ih;
  tmp.getContext('2d').putImageData(originalImageData,0,0);
  
  const items = document.querySelectorAll('.filterItem');
  items.forEach(async (el, idx)=>{
    const canvasThumb = el.querySelector('canvas');
    const ctxT = canvasThumb.getContext('2d');
    const tw = canvasThumb.width, th = canvasThumb.height;
    
    ctxT.clearRect(0,0,tw,th);
    ctxT.drawImage(tmp, 0,0, iw, ih, 0,0, tw, th);
    
    const filterId = el.dataset.filter;
    const idata = ctxT.getImageData(0,0,tw,th);
    
    if(filterId === 'sepia'){
      const out = applySepiaToImageData(idata, 1.0);
      ctxT.putImageData(out,0,0);
    } else if(filterId === 'retro'){
      const out = applyRetroToImageData(idata, 1.0);
      ctxT.putImageData(out,0,0);
    } else if(filterId === 'mini'){
      const out = await applyMiniature(idata, 1.0);
      ctxT.putImageData(out,0,0);
    }
  });
}

/* initialize UI */
createFilterBar();
setActiveFilter('original');

/* D&D support */
canvas.addEventListener('dragover', (e)=>{ e.preventDefault(); });
canvas.addEventListener('drop', (e)=>{
  e.preventDefault();
  const f = e.dataTransfer.files && e.dataTransfer.files[0];
  if(f){
    showLoading(true);
    const url = URL.createObjectURL(f);
    loadImage(url).then(()=>{ 
        URL.revokeObjectURL(url);
        showLoading(false);
    });
  }
});

/* placeholder */
function drawPlaceholder(){
  ctx.clearRect(0,0,canvas.width, canvas.height);
  const w = canvas.width = Math.min(900, Math.max(600, window.innerWidth - 120));
  const h = canvas.height = Math.round(w * 0.62);
  ctx.fillStyle = '#111';
  ctx.fillRect(0,0,w,h);
  ctx.fillStyle = '#ddd';
  ctx.font = '16px system-ui, -apple-system';
  ctx.textAlign = 'center';
  ctx.fillText('「写真を選ぶ」をタップしてください', w/2, h/2);
}
drawPlaceholder();

</script>
</body>
</html>



